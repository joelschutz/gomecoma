// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/joelschutz/gomecoma/src/ent/file"
	"github.com/joelschutz/gomecoma/src/ent/movie"
	"github.com/joelschutz/gomecoma/src/ent/picture"
)

// Movie is the model entity for the Movie schema.
type Movie struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Title holds the value of the "title" field.
	Title string `json:"title,omitempty"`
	// OriginalTitle holds the value of the "original_title" field.
	OriginalTitle string `json:"original_title,omitempty"`
	// ReleaseDate holds the value of the "release_date" field.
	ReleaseDate time.Time `json:"release_date,omitempty"`
	// Plot holds the value of the "plot" field.
	Plot string `json:"plot,omitempty"`
	// Duration holds the value of the "duration" field.
	Duration int `json:"duration,omitempty"`
	// Watched holds the value of the "watched" field.
	Watched bool `json:"watched,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the MovieQuery when eager-loading is set.
	Edges        MovieEdges `json:"edges"`
	movie_poster *int
}

// MovieEdges holds the relations/edges for other nodes in the graph.
type MovieEdges struct {
	// File holds the value of the file edge.
	File *File `json:"file,omitempty"`
	// Ratings holds the value of the ratings edge.
	Ratings []*Rating `json:"ratings,omitempty"`
	// Poster holds the value of the poster edge.
	Poster *Picture `json:"poster,omitempty"`
	// Fanart holds the value of the fanart edge.
	Fanart []*Picture `json:"fanart,omitempty"`
	// Cast holds the value of the cast edge.
	Cast []*Artist `json:"cast,omitempty"`
	// Directors holds the value of the directors edge.
	Directors []*Artist `json:"directors,omitempty"`
	// Writers holds the value of the writers edge.
	Writers []*Artist `json:"writers,omitempty"`
	// Genres holds the value of the genres edge.
	Genres []*MovieGenre `json:"genres,omitempty"`
	// Countries holds the value of the countries edge.
	Countries []*Country `json:"countries,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [9]bool
}

// FileOrErr returns the File value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e MovieEdges) FileOrErr() (*File, error) {
	if e.loadedTypes[0] {
		if e.File == nil {
			// The edge file was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: file.Label}
		}
		return e.File, nil
	}
	return nil, &NotLoadedError{edge: "file"}
}

// RatingsOrErr returns the Ratings value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) RatingsOrErr() ([]*Rating, error) {
	if e.loadedTypes[1] {
		return e.Ratings, nil
	}
	return nil, &NotLoadedError{edge: "ratings"}
}

// PosterOrErr returns the Poster value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e MovieEdges) PosterOrErr() (*Picture, error) {
	if e.loadedTypes[2] {
		if e.Poster == nil {
			// The edge poster was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: picture.Label}
		}
		return e.Poster, nil
	}
	return nil, &NotLoadedError{edge: "poster"}
}

// FanartOrErr returns the Fanart value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) FanartOrErr() ([]*Picture, error) {
	if e.loadedTypes[3] {
		return e.Fanart, nil
	}
	return nil, &NotLoadedError{edge: "fanart"}
}

// CastOrErr returns the Cast value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) CastOrErr() ([]*Artist, error) {
	if e.loadedTypes[4] {
		return e.Cast, nil
	}
	return nil, &NotLoadedError{edge: "cast"}
}

// DirectorsOrErr returns the Directors value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) DirectorsOrErr() ([]*Artist, error) {
	if e.loadedTypes[5] {
		return e.Directors, nil
	}
	return nil, &NotLoadedError{edge: "directors"}
}

// WritersOrErr returns the Writers value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) WritersOrErr() ([]*Artist, error) {
	if e.loadedTypes[6] {
		return e.Writers, nil
	}
	return nil, &NotLoadedError{edge: "writers"}
}

// GenresOrErr returns the Genres value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) GenresOrErr() ([]*MovieGenre, error) {
	if e.loadedTypes[7] {
		return e.Genres, nil
	}
	return nil, &NotLoadedError{edge: "genres"}
}

// CountriesOrErr returns the Countries value or an error if the edge
// was not loaded in eager-loading.
func (e MovieEdges) CountriesOrErr() ([]*Country, error) {
	if e.loadedTypes[8] {
		return e.Countries, nil
	}
	return nil, &NotLoadedError{edge: "countries"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Movie) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case movie.FieldWatched:
			values[i] = new(sql.NullBool)
		case movie.FieldID, movie.FieldDuration:
			values[i] = new(sql.NullInt64)
		case movie.FieldTitle, movie.FieldOriginalTitle, movie.FieldPlot:
			values[i] = new(sql.NullString)
		case movie.FieldReleaseDate:
			values[i] = new(sql.NullTime)
		case movie.ForeignKeys[0]: // movie_poster
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Movie", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Movie fields.
func (m *Movie) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case movie.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			m.ID = int(value.Int64)
		case movie.FieldTitle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field title", values[i])
			} else if value.Valid {
				m.Title = value.String
			}
		case movie.FieldOriginalTitle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field original_title", values[i])
			} else if value.Valid {
				m.OriginalTitle = value.String
			}
		case movie.FieldReleaseDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field release_date", values[i])
			} else if value.Valid {
				m.ReleaseDate = value.Time
			}
		case movie.FieldPlot:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field plot", values[i])
			} else if value.Valid {
				m.Plot = value.String
			}
		case movie.FieldDuration:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration", values[i])
			} else if value.Valid {
				m.Duration = int(value.Int64)
			}
		case movie.FieldWatched:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field watched", values[i])
			} else if value.Valid {
				m.Watched = value.Bool
			}
		case movie.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field movie_poster", value)
			} else if value.Valid {
				m.movie_poster = new(int)
				*m.movie_poster = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryFile queries the "file" edge of the Movie entity.
func (m *Movie) QueryFile() *FileQuery {
	return (&MovieClient{config: m.config}).QueryFile(m)
}

// QueryRatings queries the "ratings" edge of the Movie entity.
func (m *Movie) QueryRatings() *RatingQuery {
	return (&MovieClient{config: m.config}).QueryRatings(m)
}

// QueryPoster queries the "poster" edge of the Movie entity.
func (m *Movie) QueryPoster() *PictureQuery {
	return (&MovieClient{config: m.config}).QueryPoster(m)
}

// QueryFanart queries the "fanart" edge of the Movie entity.
func (m *Movie) QueryFanart() *PictureQuery {
	return (&MovieClient{config: m.config}).QueryFanart(m)
}

// QueryCast queries the "cast" edge of the Movie entity.
func (m *Movie) QueryCast() *ArtistQuery {
	return (&MovieClient{config: m.config}).QueryCast(m)
}

// QueryDirectors queries the "directors" edge of the Movie entity.
func (m *Movie) QueryDirectors() *ArtistQuery {
	return (&MovieClient{config: m.config}).QueryDirectors(m)
}

// QueryWriters queries the "writers" edge of the Movie entity.
func (m *Movie) QueryWriters() *ArtistQuery {
	return (&MovieClient{config: m.config}).QueryWriters(m)
}

// QueryGenres queries the "genres" edge of the Movie entity.
func (m *Movie) QueryGenres() *MovieGenreQuery {
	return (&MovieClient{config: m.config}).QueryGenres(m)
}

// QueryCountries queries the "countries" edge of the Movie entity.
func (m *Movie) QueryCountries() *CountryQuery {
	return (&MovieClient{config: m.config}).QueryCountries(m)
}

// Update returns a builder for updating this Movie.
// Note that you need to call Movie.Unwrap() before calling this method if this Movie
// was returned from a transaction, and the transaction was committed or rolled back.
func (m *Movie) Update() *MovieUpdateOne {
	return (&MovieClient{config: m.config}).UpdateOne(m)
}

// Unwrap unwraps the Movie entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (m *Movie) Unwrap() *Movie {
	tx, ok := m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Movie is not a transactional entity")
	}
	m.config.driver = tx.drv
	return m
}

// String implements the fmt.Stringer.
func (m *Movie) String() string {
	var builder strings.Builder
	builder.WriteString("Movie(")
	builder.WriteString(fmt.Sprintf("id=%v", m.ID))
	builder.WriteString(", title=")
	builder.WriteString(m.Title)
	builder.WriteString(", original_title=")
	builder.WriteString(m.OriginalTitle)
	builder.WriteString(", release_date=")
	builder.WriteString(m.ReleaseDate.Format(time.ANSIC))
	builder.WriteString(", plot=")
	builder.WriteString(m.Plot)
	builder.WriteString(", duration=")
	builder.WriteString(fmt.Sprintf("%v", m.Duration))
	builder.WriteString(", watched=")
	builder.WriteString(fmt.Sprintf("%v", m.Watched))
	builder.WriteByte(')')
	return builder.String()
}

// Movies is a parsable slice of Movie.
type Movies []*Movie

func (m Movies) config(cfg config) {
	for _i := range m {
		m[_i].config = cfg
	}
}
