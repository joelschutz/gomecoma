// Code generated by entc, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/joelschutz/gomecoma/src/ent"
	"github.com/joelschutz/gomecoma/src/ent/artist"
	"github.com/joelschutz/gomecoma/src/ent/country"
	"github.com/joelschutz/gomecoma/src/ent/file"
	"github.com/joelschutz/gomecoma/src/ent/movie"
	"github.com/joelschutz/gomecoma/src/ent/moviegenre"
	"github.com/joelschutz/gomecoma/src/ent/picture"
	"github.com/joelschutz/gomecoma/src/ent/rating"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateArtist handles POST /artists requests.
func (h *OgentHandler) CreateArtist(ctx context.Context, req CreateArtistReq) (CreateArtistRes, error) {
	b := h.client.Artist.Create()
	// Add all fields.
	b.SetName(req.Name)
	if v, ok := req.Birthday.Get(); ok {
		b.SetBirthday(v)
	}
	// Add all edges.
	if v, ok := req.ProfilePicture.Get(); ok {
		b.SetProfilePictureID(v)
	}
	b.AddPictureIDs(req.Pictures...)
	b.AddDirectedIDs(req.Directed...)
	b.AddActedIDs(req.Acted...)
	b.AddWroteIDs(req.Wrote...)
	b.AddCountryIDs(req.Countries...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Artist.Query().Where(artist.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewArtistCreate(e), nil
}

// ReadArtist handles GET /artists/{id} requests.
func (h *OgentHandler) ReadArtist(ctx context.Context, params ReadArtistParams) (ReadArtistRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewArtistRead(e), nil
}

// UpdateArtist handles PATCH /artists/{id} requests.
func (h *OgentHandler) UpdateArtist(ctx context.Context, req UpdateArtistReq, params UpdateArtistParams) (UpdateArtistRes, error) {
	b := h.client.Artist.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Birthday.Get(); ok {
		b.SetBirthday(v)
	}
	// Add all edges.
	if v, ok := req.ProfilePicture.Get(); ok {
		b.SetProfilePictureID(v)
	}
	b.ClearPictures().AddPictureIDs(req.Pictures...)
	b.ClearDirected().AddDirectedIDs(req.Directed...)
	b.ClearActed().AddActedIDs(req.Acted...)
	b.ClearWrote().AddWroteIDs(req.Wrote...)
	b.ClearCountries().AddCountryIDs(req.Countries...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Artist.Query().Where(artist.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewArtistUpdate(e), nil
}

// DeleteArtist handles DELETE /artists/{id} requests.
func (h *OgentHandler) DeleteArtist(ctx context.Context, params DeleteArtistParams) (DeleteArtistRes, error) {
	err := h.client.Artist.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteArtistNoContent), nil

}

// ListArtist handles GET /artists requests.
func (h *OgentHandler) ListArtist(ctx context.Context, params ListArtistParams) (ListArtistRes, error) {
	q := h.client.Artist.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewArtistLists(es)
	return (*ListArtistOKApplicationJSON)(&r), nil
}

// ReadArtistProfilePicture handles GET /artists/{id}/profile-picture requests.
func (h *OgentHandler) ReadArtistProfilePicture(ctx context.Context, params ReadArtistProfilePictureParams) (ReadArtistProfilePictureRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID)).QueryProfilePicture()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewArtistProfilePictureRead(e), nil
}

// ListArtistPictures handles GET /artists/{id}/pictures requests.
func (h *OgentHandler) ListArtistPictures(ctx context.Context, params ListArtistPicturesParams) (ListArtistPicturesRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID)).QueryPictures()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewArtistPicturesLists(es)
	return (*ListArtistPicturesOKApplicationJSON)(&r), nil
}

// ListArtistDirected handles GET /artists/{id}/directed requests.
func (h *OgentHandler) ListArtistDirected(ctx context.Context, params ListArtistDirectedParams) (ListArtistDirectedRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID)).QueryDirected()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewArtistDirectedLists(es)
	return (*ListArtistDirectedOKApplicationJSON)(&r), nil
}

// ListArtistActed handles GET /artists/{id}/acted requests.
func (h *OgentHandler) ListArtistActed(ctx context.Context, params ListArtistActedParams) (ListArtistActedRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID)).QueryActed()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewArtistActedLists(es)
	return (*ListArtistActedOKApplicationJSON)(&r), nil
}

// ListArtistWrote handles GET /artists/{id}/wrote requests.
func (h *OgentHandler) ListArtistWrote(ctx context.Context, params ListArtistWroteParams) (ListArtistWroteRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID)).QueryWrote()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewArtistWroteLists(es)
	return (*ListArtistWroteOKApplicationJSON)(&r), nil
}

// ListArtistCountries handles GET /artists/{id}/countries requests.
func (h *OgentHandler) ListArtistCountries(ctx context.Context, params ListArtistCountriesParams) (ListArtistCountriesRes, error) {
	q := h.client.Artist.Query().Where(artist.IDEQ(params.ID)).QueryCountries()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewArtistCountriesLists(es)
	return (*ListArtistCountriesOKApplicationJSON)(&r), nil
}

// CreateCountry handles POST /countries requests.
func (h *OgentHandler) CreateCountry(ctx context.Context, req CreateCountryReq) (CreateCountryRes, error) {
	b := h.client.Country.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetCode(req.Code)
	// Add all edges.
	b.AddMovieIDs(req.Movies...)
	b.AddArtistIDs(req.Artists...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Country.Query().Where(country.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCountryCreate(e), nil
}

// ReadCountry handles GET /countries/{id} requests.
func (h *OgentHandler) ReadCountry(ctx context.Context, params ReadCountryParams) (ReadCountryRes, error) {
	q := h.client.Country.Query().Where(country.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCountryRead(e), nil
}

// UpdateCountry handles PATCH /countries/{id} requests.
func (h *OgentHandler) UpdateCountry(ctx context.Context, req UpdateCountryReq, params UpdateCountryParams) (UpdateCountryRes, error) {
	b := h.client.Country.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Code.Get(); ok {
		b.SetCode(v)
	}
	// Add all edges.
	b.ClearMovies().AddMovieIDs(req.Movies...)
	b.ClearArtists().AddArtistIDs(req.Artists...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Country.Query().Where(country.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCountryUpdate(e), nil
}

// DeleteCountry handles DELETE /countries/{id} requests.
func (h *OgentHandler) DeleteCountry(ctx context.Context, params DeleteCountryParams) (DeleteCountryRes, error) {
	err := h.client.Country.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCountryNoContent), nil

}

// ListCountry handles GET /countries requests.
func (h *OgentHandler) ListCountry(ctx context.Context, params ListCountryParams) (ListCountryRes, error) {
	q := h.client.Country.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCountryLists(es)
	return (*ListCountryOKApplicationJSON)(&r), nil
}

// ListCountryMovies handles GET /countries/{id}/movies requests.
func (h *OgentHandler) ListCountryMovies(ctx context.Context, params ListCountryMoviesParams) (ListCountryMoviesRes, error) {
	q := h.client.Country.Query().Where(country.IDEQ(params.ID)).QueryMovies()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCountryMoviesLists(es)
	return (*ListCountryMoviesOKApplicationJSON)(&r), nil
}

// ListCountryArtists handles GET /countries/{id}/artists requests.
func (h *OgentHandler) ListCountryArtists(ctx context.Context, params ListCountryArtistsParams) (ListCountryArtistsRes, error) {
	q := h.client.Country.Query().Where(country.IDEQ(params.ID)).QueryArtists()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCountryArtistsLists(es)
	return (*ListCountryArtistsOKApplicationJSON)(&r), nil
}

// CreateFile handles POST /files requests.
func (h *OgentHandler) CreateFile(ctx context.Context, req CreateFileReq) (CreateFileRes, error) {
	b := h.client.File.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetPath(req.Path)
	b.SetType(file.Type(req.Type))
	if v, ok := req.ExternalID.Get(); ok {
		b.SetExternalID(v)
	}
	if v, ok := req.ExternalInfoProvider.Get(); ok {
		b.SetExternalInfoProvider(v)
	}
	if v, ok := req.Results.Get(); ok {
		b.SetResults(v)
	}
	b.SetSynced(req.Synced)
	// Add all edges.
	if v, ok := req.Movie.Get(); ok {
		b.SetMovieID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.File.Query().Where(file.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewFileCreate(e), nil
}

// ReadFile handles GET /files/{id} requests.
func (h *OgentHandler) ReadFile(ctx context.Context, params ReadFileParams) (ReadFileRes, error) {
	q := h.client.File.Query().Where(file.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewFileRead(e), nil
}

// UpdateFile handles PATCH /files/{id} requests.
func (h *OgentHandler) UpdateFile(ctx context.Context, req UpdateFileReq, params UpdateFileParams) (UpdateFileRes, error) {
	b := h.client.File.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Path.Get(); ok {
		b.SetPath(v)
	}
	if v, ok := req.Type.Get(); ok {
		b.SetType(file.Type(v))
	}
	if v, ok := req.ExternalID.Get(); ok {
		b.SetExternalID(v)
	}
	if v, ok := req.ExternalInfoProvider.Get(); ok {
		b.SetExternalInfoProvider(v)
	}
	if v, ok := req.Results.Get(); ok {
		b.SetResults(v)
	}
	if v, ok := req.Synced.Get(); ok {
		b.SetSynced(v)
	}
	// Add all edges.
	if v, ok := req.Movie.Get(); ok {
		b.SetMovieID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.File.Query().Where(file.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewFileUpdate(e), nil
}

// DeleteFile handles DELETE /files/{id} requests.
func (h *OgentHandler) DeleteFile(ctx context.Context, params DeleteFileParams) (DeleteFileRes, error) {
	err := h.client.File.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteFileNoContent), nil

}

// ListFile handles GET /files requests.
func (h *OgentHandler) ListFile(ctx context.Context, params ListFileParams) (ListFileRes, error) {
	q := h.client.File.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewFileLists(es)
	return (*ListFileOKApplicationJSON)(&r), nil
}

// ReadFileMovie handles GET /files/{id}/movie requests.
func (h *OgentHandler) ReadFileMovie(ctx context.Context, params ReadFileMovieParams) (ReadFileMovieRes, error) {
	q := h.client.File.Query().Where(file.IDEQ(params.ID)).QueryMovie()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewFileMovieRead(e), nil
}

// CreateMovie handles POST /movies requests.
func (h *OgentHandler) CreateMovie(ctx context.Context, req CreateMovieReq) (CreateMovieRes, error) {
	b := h.client.Movie.Create()
	// Add all fields.
	b.SetTitle(req.Title)
	if v, ok := req.OriginalTitle.Get(); ok {
		b.SetOriginalTitle(v)
	}
	if v, ok := req.ReleaseDate.Get(); ok {
		b.SetReleaseDate(v)
	}
	if v, ok := req.Plot.Get(); ok {
		b.SetPlot(v)
	}
	if v, ok := req.Duration.Get(); ok {
		b.SetDuration(v)
	}
	b.SetWatched(req.Watched)
	// Add all edges.
	if v, ok := req.File.Get(); ok {
		b.SetFileID(v)
	}
	b.AddRatingIDs(req.Ratings...)
	if v, ok := req.Poster.Get(); ok {
		b.SetPosterID(v)
	}
	b.AddFanartIDs(req.Fanart...)
	b.AddCastIDs(req.Cast...)
	b.AddDirectorIDs(req.Directors...)
	b.AddWriterIDs(req.Writers...)
	b.AddGenreIDs(req.Genres...)
	b.AddCountryIDs(req.Countries...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Movie.Query().Where(movie.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMovieCreate(e), nil
}

// ReadMovie handles GET /movies/{id} requests.
func (h *OgentHandler) ReadMovie(ctx context.Context, params ReadMovieParams) (ReadMovieRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMovieRead(e), nil
}

// UpdateMovie handles PATCH /movies/{id} requests.
func (h *OgentHandler) UpdateMovie(ctx context.Context, req UpdateMovieReq, params UpdateMovieParams) (UpdateMovieRes, error) {
	b := h.client.Movie.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Title.Get(); ok {
		b.SetTitle(v)
	}
	if v, ok := req.OriginalTitle.Get(); ok {
		b.SetOriginalTitle(v)
	}
	if v, ok := req.ReleaseDate.Get(); ok {
		b.SetReleaseDate(v)
	}
	if v, ok := req.Plot.Get(); ok {
		b.SetPlot(v)
	}
	if v, ok := req.Duration.Get(); ok {
		b.SetDuration(v)
	}
	if v, ok := req.Watched.Get(); ok {
		b.SetWatched(v)
	}
	// Add all edges.
	if v, ok := req.File.Get(); ok {
		b.SetFileID(v)
	}
	b.ClearRatings().AddRatingIDs(req.Ratings...)
	if v, ok := req.Poster.Get(); ok {
		b.SetPosterID(v)
	}
	b.ClearFanart().AddFanartIDs(req.Fanart...)
	b.ClearCast().AddCastIDs(req.Cast...)
	b.ClearDirectors().AddDirectorIDs(req.Directors...)
	b.ClearWriters().AddWriterIDs(req.Writers...)
	b.ClearGenres().AddGenreIDs(req.Genres...)
	b.ClearCountries().AddCountryIDs(req.Countries...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Movie.Query().Where(movie.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMovieUpdate(e), nil
}

// DeleteMovie handles DELETE /movies/{id} requests.
func (h *OgentHandler) DeleteMovie(ctx context.Context, params DeleteMovieParams) (DeleteMovieRes, error) {
	err := h.client.Movie.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMovieNoContent), nil

}

// ListMovie handles GET /movies requests.
func (h *OgentHandler) ListMovie(ctx context.Context, params ListMovieParams) (ListMovieRes, error) {
	q := h.client.Movie.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieLists(es)
	return (*ListMovieOKApplicationJSON)(&r), nil
}

// ReadMovieFile handles GET /movies/{id}/file requests.
func (h *OgentHandler) ReadMovieFile(ctx context.Context, params ReadMovieFileParams) (ReadMovieFileRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryFile()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMovieFileRead(e), nil
}

// ListMovieRatings handles GET /movies/{id}/ratings requests.
func (h *OgentHandler) ListMovieRatings(ctx context.Context, params ListMovieRatingsParams) (ListMovieRatingsRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryRatings()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieRatingsLists(es)
	return (*ListMovieRatingsOKApplicationJSON)(&r), nil
}

// ReadMoviePoster handles GET /movies/{id}/poster requests.
func (h *OgentHandler) ReadMoviePoster(ctx context.Context, params ReadMoviePosterParams) (ReadMoviePosterRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryPoster()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMoviePosterRead(e), nil
}

// ListMovieFanart handles GET /movies/{id}/fanart requests.
func (h *OgentHandler) ListMovieFanart(ctx context.Context, params ListMovieFanartParams) (ListMovieFanartRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryFanart()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieFanartLists(es)
	return (*ListMovieFanartOKApplicationJSON)(&r), nil
}

// ListMovieCast handles GET /movies/{id}/cast requests.
func (h *OgentHandler) ListMovieCast(ctx context.Context, params ListMovieCastParams) (ListMovieCastRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryCast()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieCastLists(es)
	return (*ListMovieCastOKApplicationJSON)(&r), nil
}

// ListMovieDirectors handles GET /movies/{id}/directors requests.
func (h *OgentHandler) ListMovieDirectors(ctx context.Context, params ListMovieDirectorsParams) (ListMovieDirectorsRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryDirectors()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieDirectorsLists(es)
	return (*ListMovieDirectorsOKApplicationJSON)(&r), nil
}

// ListMovieWriters handles GET /movies/{id}/writers requests.
func (h *OgentHandler) ListMovieWriters(ctx context.Context, params ListMovieWritersParams) (ListMovieWritersRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryWriters()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieWritersLists(es)
	return (*ListMovieWritersOKApplicationJSON)(&r), nil
}

// ListMovieGenres handles GET /movies/{id}/genres requests.
func (h *OgentHandler) ListMovieGenres(ctx context.Context, params ListMovieGenresParams) (ListMovieGenresRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryGenres()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieGenresLists(es)
	return (*ListMovieGenresOKApplicationJSON)(&r), nil
}

// ListMovieCountries handles GET /movies/{id}/countries requests.
func (h *OgentHandler) ListMovieCountries(ctx context.Context, params ListMovieCountriesParams) (ListMovieCountriesRes, error) {
	q := h.client.Movie.Query().Where(movie.IDEQ(params.ID)).QueryCountries()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieCountriesLists(es)
	return (*ListMovieCountriesOKApplicationJSON)(&r), nil
}

// CreateMovieGenre handles POST /movie-genres requests.
func (h *OgentHandler) CreateMovieGenre(ctx context.Context, req CreateMovieGenreReq) (CreateMovieGenreRes, error) {
	b := h.client.MovieGenre.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	b.AddMovieIDs(req.Movies...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MovieGenre.Query().Where(moviegenre.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMovieGenreCreate(e), nil
}

// ReadMovieGenre handles GET /movie-genres/{id} requests.
func (h *OgentHandler) ReadMovieGenre(ctx context.Context, params ReadMovieGenreParams) (ReadMovieGenreRes, error) {
	q := h.client.MovieGenre.Query().Where(moviegenre.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMovieGenreRead(e), nil
}

// UpdateMovieGenre handles PATCH /movie-genres/{id} requests.
func (h *OgentHandler) UpdateMovieGenre(ctx context.Context, req UpdateMovieGenreReq, params UpdateMovieGenreParams) (UpdateMovieGenreRes, error) {
	b := h.client.MovieGenre.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	b.ClearMovies().AddMovieIDs(req.Movies...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MovieGenre.Query().Where(moviegenre.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMovieGenreUpdate(e), nil
}

// DeleteMovieGenre handles DELETE /movie-genres/{id} requests.
func (h *OgentHandler) DeleteMovieGenre(ctx context.Context, params DeleteMovieGenreParams) (DeleteMovieGenreRes, error) {
	err := h.client.MovieGenre.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMovieGenreNoContent), nil

}

// ListMovieGenre handles GET /movie-genres requests.
func (h *OgentHandler) ListMovieGenre(ctx context.Context, params ListMovieGenreParams) (ListMovieGenreRes, error) {
	q := h.client.MovieGenre.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieGenreLists(es)
	return (*ListMovieGenreOKApplicationJSON)(&r), nil
}

// ListMovieGenreMovies handles GET /movie-genres/{id}/movies requests.
func (h *OgentHandler) ListMovieGenreMovies(ctx context.Context, params ListMovieGenreMoviesParams) (ListMovieGenreMoviesRes, error) {
	q := h.client.MovieGenre.Query().Where(moviegenre.IDEQ(params.ID)).QueryMovies()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMovieGenreMoviesLists(es)
	return (*ListMovieGenreMoviesOKApplicationJSON)(&r), nil
}

// CreatePicture handles POST /pictures requests.
func (h *OgentHandler) CreatePicture(ctx context.Context, req CreatePictureReq) (CreatePictureRes, error) {
	b := h.client.Picture.Create()
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	b.SetFilename(req.Filename)
	b.SetPath(req.Path)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Picture.Query().Where(picture.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPictureCreate(e), nil
}

// ReadPicture handles GET /pictures/{id} requests.
func (h *OgentHandler) ReadPicture(ctx context.Context, params ReadPictureParams) (ReadPictureRes, error) {
	q := h.client.Picture.Query().Where(picture.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPictureRead(e), nil
}

// UpdatePicture handles PATCH /pictures/{id} requests.
func (h *OgentHandler) UpdatePicture(ctx context.Context, req UpdatePictureReq, params UpdatePictureParams) (UpdatePictureRes, error) {
	b := h.client.Picture.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Filename.Get(); ok {
		b.SetFilename(v)
	}
	if v, ok := req.Path.Get(); ok {
		b.SetPath(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Picture.Query().Where(picture.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPictureUpdate(e), nil
}

// DeletePicture handles DELETE /pictures/{id} requests.
func (h *OgentHandler) DeletePicture(ctx context.Context, params DeletePictureParams) (DeletePictureRes, error) {
	err := h.client.Picture.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeletePictureNoContent), nil

}

// ListPicture handles GET /pictures requests.
func (h *OgentHandler) ListPicture(ctx context.Context, params ListPictureParams) (ListPictureRes, error) {
	q := h.client.Picture.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPictureLists(es)
	return (*ListPictureOKApplicationJSON)(&r), nil
}

// CreateRating handles POST /ratings requests.
func (h *OgentHandler) CreateRating(ctx context.Context, req CreateRatingReq) (CreateRatingRes, error) {
	b := h.client.Rating.Create()
	// Add all fields.
	b.SetOrigin(req.Origin)
	b.SetOriginalRating(req.OriginalRating)
	b.SetNormalizedRating(req.NormalizedRating)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Rating.Query().Where(rating.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRatingCreate(e), nil
}

// ReadRating handles GET /ratings/{id} requests.
func (h *OgentHandler) ReadRating(ctx context.Context, params ReadRatingParams) (ReadRatingRes, error) {
	q := h.client.Rating.Query().Where(rating.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRatingRead(e), nil
}

// UpdateRating handles PATCH /ratings/{id} requests.
func (h *OgentHandler) UpdateRating(ctx context.Context, req UpdateRatingReq, params UpdateRatingParams) (UpdateRatingRes, error) {
	b := h.client.Rating.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Origin.Get(); ok {
		b.SetOrigin(v)
	}
	if v, ok := req.OriginalRating.Get(); ok {
		b.SetOriginalRating(v)
	}
	if v, ok := req.NormalizedRating.Get(); ok {
		b.SetNormalizedRating(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Rating.Query().Where(rating.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRatingUpdate(e), nil
}

// DeleteRating handles DELETE /ratings/{id} requests.
func (h *OgentHandler) DeleteRating(ctx context.Context, params DeleteRatingParams) (DeleteRatingRes, error) {
	err := h.client.Rating.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteRatingNoContent), nil

}

// ListRating handles GET /ratings requests.
func (h *OgentHandler) ListRating(ctx context.Context, params ListRatingParams) (ListRatingRes, error) {
	q := h.client.Rating.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRatingLists(es)
	return (*ListRatingOKApplicationJSON)(&r), nil
}
