// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/joelschutz/gomecoma/src/ent/artist"
	"github.com/joelschutz/gomecoma/src/ent/country"
	"github.com/joelschutz/gomecoma/src/ent/file"
	"github.com/joelschutz/gomecoma/src/ent/movie"
	"github.com/joelschutz/gomecoma/src/ent/moviegenre"
	"github.com/joelschutz/gomecoma/src/ent/picture"
	"github.com/joelschutz/gomecoma/src/ent/predicate"
	"github.com/joelschutz/gomecoma/src/ent/rating"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtist     = "Artist"
	TypeCountry    = "Country"
	TypeFile       = "File"
	TypeMovie      = "Movie"
	TypeMovieGenre = "MovieGenre"
	TypePicture    = "Picture"
	TypeRating     = "Rating"
)

// ArtistMutation represents an operation that mutates the Artist nodes in the graph.
type ArtistMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	birthday               *time.Time
	clearedFields          map[string]struct{}
	profile_picture        *int
	clearedprofile_picture bool
	pictures               map[int]struct{}
	removedpictures        map[int]struct{}
	clearedpictures        bool
	directed               map[int]struct{}
	removeddirected        map[int]struct{}
	cleareddirected        bool
	acted                  map[int]struct{}
	removedacted           map[int]struct{}
	clearedacted           bool
	wrote                  map[int]struct{}
	removedwrote           map[int]struct{}
	clearedwrote           bool
	countries              map[int]struct{}
	removedcountries       map[int]struct{}
	clearedcountries       bool
	done                   bool
	oldValue               func(context.Context) (*Artist, error)
	predicates             []predicate.Artist
}

var _ ent.Mutation = (*ArtistMutation)(nil)

// artistOption allows management of the mutation configuration using functional options.
type artistOption func(*ArtistMutation)

// newArtistMutation creates new mutation for the Artist entity.
func newArtistMutation(c config, op Op, opts ...artistOption) *ArtistMutation {
	m := &ArtistMutation{
		config:        c,
		op:            op,
		typ:           TypeArtist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtistID sets the ID field of the mutation.
func withArtistID(id int) artistOption {
	return func(m *ArtistMutation) {
		var (
			err   error
			once  sync.Once
			value *Artist
		)
		m.oldValue = func(ctx context.Context) (*Artist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtist sets the old Artist of the mutation.
func withArtist(node *Artist) artistOption {
	return func(m *ArtistMutation) {
		m.oldValue = func(context.Context) (*Artist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ArtistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtistMutation) ResetName() {
	m.name = nil
}

// SetBirthday sets the "birthday" field.
func (m *ArtistMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *ArtistMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *ArtistMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[artist.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *ArtistMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[artist.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *ArtistMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, artist.FieldBirthday)
}

// SetProfilePictureID sets the "profile_picture" edge to the Picture entity by id.
func (m *ArtistMutation) SetProfilePictureID(id int) {
	m.profile_picture = &id
}

// ClearProfilePicture clears the "profile_picture" edge to the Picture entity.
func (m *ArtistMutation) ClearProfilePicture() {
	m.clearedprofile_picture = true
}

// ProfilePictureCleared reports if the "profile_picture" edge to the Picture entity was cleared.
func (m *ArtistMutation) ProfilePictureCleared() bool {
	return m.clearedprofile_picture
}

// ProfilePictureID returns the "profile_picture" edge ID in the mutation.
func (m *ArtistMutation) ProfilePictureID() (id int, exists bool) {
	if m.profile_picture != nil {
		return *m.profile_picture, true
	}
	return
}

// ProfilePictureIDs returns the "profile_picture" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfilePictureID instead. It exists only for internal usage by the builders.
func (m *ArtistMutation) ProfilePictureIDs() (ids []int) {
	if id := m.profile_picture; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfilePicture resets all changes to the "profile_picture" edge.
func (m *ArtistMutation) ResetProfilePicture() {
	m.profile_picture = nil
	m.clearedprofile_picture = false
}

// AddPictureIDs adds the "pictures" edge to the Picture entity by ids.
func (m *ArtistMutation) AddPictureIDs(ids ...int) {
	if m.pictures == nil {
		m.pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.pictures[ids[i]] = struct{}{}
	}
}

// ClearPictures clears the "pictures" edge to the Picture entity.
func (m *ArtistMutation) ClearPictures() {
	m.clearedpictures = true
}

// PicturesCleared reports if the "pictures" edge to the Picture entity was cleared.
func (m *ArtistMutation) PicturesCleared() bool {
	return m.clearedpictures
}

// RemovePictureIDs removes the "pictures" edge to the Picture entity by IDs.
func (m *ArtistMutation) RemovePictureIDs(ids ...int) {
	if m.removedpictures == nil {
		m.removedpictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pictures, ids[i])
		m.removedpictures[ids[i]] = struct{}{}
	}
}

// RemovedPictures returns the removed IDs of the "pictures" edge to the Picture entity.
func (m *ArtistMutation) RemovedPicturesIDs() (ids []int) {
	for id := range m.removedpictures {
		ids = append(ids, id)
	}
	return
}

// PicturesIDs returns the "pictures" edge IDs in the mutation.
func (m *ArtistMutation) PicturesIDs() (ids []int) {
	for id := range m.pictures {
		ids = append(ids, id)
	}
	return
}

// ResetPictures resets all changes to the "pictures" edge.
func (m *ArtistMutation) ResetPictures() {
	m.pictures = nil
	m.clearedpictures = false
	m.removedpictures = nil
}

// AddDirectedIDs adds the "directed" edge to the Movie entity by ids.
func (m *ArtistMutation) AddDirectedIDs(ids ...int) {
	if m.directed == nil {
		m.directed = make(map[int]struct{})
	}
	for i := range ids {
		m.directed[ids[i]] = struct{}{}
	}
}

// ClearDirected clears the "directed" edge to the Movie entity.
func (m *ArtistMutation) ClearDirected() {
	m.cleareddirected = true
}

// DirectedCleared reports if the "directed" edge to the Movie entity was cleared.
func (m *ArtistMutation) DirectedCleared() bool {
	return m.cleareddirected
}

// RemoveDirectedIDs removes the "directed" edge to the Movie entity by IDs.
func (m *ArtistMutation) RemoveDirectedIDs(ids ...int) {
	if m.removeddirected == nil {
		m.removeddirected = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.directed, ids[i])
		m.removeddirected[ids[i]] = struct{}{}
	}
}

// RemovedDirected returns the removed IDs of the "directed" edge to the Movie entity.
func (m *ArtistMutation) RemovedDirectedIDs() (ids []int) {
	for id := range m.removeddirected {
		ids = append(ids, id)
	}
	return
}

// DirectedIDs returns the "directed" edge IDs in the mutation.
func (m *ArtistMutation) DirectedIDs() (ids []int) {
	for id := range m.directed {
		ids = append(ids, id)
	}
	return
}

// ResetDirected resets all changes to the "directed" edge.
func (m *ArtistMutation) ResetDirected() {
	m.directed = nil
	m.cleareddirected = false
	m.removeddirected = nil
}

// AddActedIDs adds the "acted" edge to the Movie entity by ids.
func (m *ArtistMutation) AddActedIDs(ids ...int) {
	if m.acted == nil {
		m.acted = make(map[int]struct{})
	}
	for i := range ids {
		m.acted[ids[i]] = struct{}{}
	}
}

// ClearActed clears the "acted" edge to the Movie entity.
func (m *ArtistMutation) ClearActed() {
	m.clearedacted = true
}

// ActedCleared reports if the "acted" edge to the Movie entity was cleared.
func (m *ArtistMutation) ActedCleared() bool {
	return m.clearedacted
}

// RemoveActedIDs removes the "acted" edge to the Movie entity by IDs.
func (m *ArtistMutation) RemoveActedIDs(ids ...int) {
	if m.removedacted == nil {
		m.removedacted = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.acted, ids[i])
		m.removedacted[ids[i]] = struct{}{}
	}
}

// RemovedActed returns the removed IDs of the "acted" edge to the Movie entity.
func (m *ArtistMutation) RemovedActedIDs() (ids []int) {
	for id := range m.removedacted {
		ids = append(ids, id)
	}
	return
}

// ActedIDs returns the "acted" edge IDs in the mutation.
func (m *ArtistMutation) ActedIDs() (ids []int) {
	for id := range m.acted {
		ids = append(ids, id)
	}
	return
}

// ResetActed resets all changes to the "acted" edge.
func (m *ArtistMutation) ResetActed() {
	m.acted = nil
	m.clearedacted = false
	m.removedacted = nil
}

// AddWroteIDs adds the "wrote" edge to the Movie entity by ids.
func (m *ArtistMutation) AddWroteIDs(ids ...int) {
	if m.wrote == nil {
		m.wrote = make(map[int]struct{})
	}
	for i := range ids {
		m.wrote[ids[i]] = struct{}{}
	}
}

// ClearWrote clears the "wrote" edge to the Movie entity.
func (m *ArtistMutation) ClearWrote() {
	m.clearedwrote = true
}

// WroteCleared reports if the "wrote" edge to the Movie entity was cleared.
func (m *ArtistMutation) WroteCleared() bool {
	return m.clearedwrote
}

// RemoveWroteIDs removes the "wrote" edge to the Movie entity by IDs.
func (m *ArtistMutation) RemoveWroteIDs(ids ...int) {
	if m.removedwrote == nil {
		m.removedwrote = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wrote, ids[i])
		m.removedwrote[ids[i]] = struct{}{}
	}
}

// RemovedWrote returns the removed IDs of the "wrote" edge to the Movie entity.
func (m *ArtistMutation) RemovedWroteIDs() (ids []int) {
	for id := range m.removedwrote {
		ids = append(ids, id)
	}
	return
}

// WroteIDs returns the "wrote" edge IDs in the mutation.
func (m *ArtistMutation) WroteIDs() (ids []int) {
	for id := range m.wrote {
		ids = append(ids, id)
	}
	return
}

// ResetWrote resets all changes to the "wrote" edge.
func (m *ArtistMutation) ResetWrote() {
	m.wrote = nil
	m.clearedwrote = false
	m.removedwrote = nil
}

// AddCountryIDs adds the "countries" edge to the Country entity by ids.
func (m *ArtistMutation) AddCountryIDs(ids ...int) {
	if m.countries == nil {
		m.countries = make(map[int]struct{})
	}
	for i := range ids {
		m.countries[ids[i]] = struct{}{}
	}
}

// ClearCountries clears the "countries" edge to the Country entity.
func (m *ArtistMutation) ClearCountries() {
	m.clearedcountries = true
}

// CountriesCleared reports if the "countries" edge to the Country entity was cleared.
func (m *ArtistMutation) CountriesCleared() bool {
	return m.clearedcountries
}

// RemoveCountryIDs removes the "countries" edge to the Country entity by IDs.
func (m *ArtistMutation) RemoveCountryIDs(ids ...int) {
	if m.removedcountries == nil {
		m.removedcountries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.countries, ids[i])
		m.removedcountries[ids[i]] = struct{}{}
	}
}

// RemovedCountries returns the removed IDs of the "countries" edge to the Country entity.
func (m *ArtistMutation) RemovedCountriesIDs() (ids []int) {
	for id := range m.removedcountries {
		ids = append(ids, id)
	}
	return
}

// CountriesIDs returns the "countries" edge IDs in the mutation.
func (m *ArtistMutation) CountriesIDs() (ids []int) {
	for id := range m.countries {
		ids = append(ids, id)
	}
	return
}

// ResetCountries resets all changes to the "countries" edge.
func (m *ArtistMutation) ResetCountries() {
	m.countries = nil
	m.clearedcountries = false
	m.removedcountries = nil
}

// Where appends a list predicates to the ArtistMutation builder.
func (m *ArtistMutation) Where(ps ...predicate.Artist) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArtistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artist).
func (m *ArtistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtistMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, artist.FieldName)
	}
	if m.birthday != nil {
		fields = append(fields, artist.FieldBirthday)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artist.FieldName:
		return m.Name()
	case artist.FieldBirthday:
		return m.Birthday()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artist.FieldName:
		return m.OldName(ctx)
	case artist.FieldBirthday:
		return m.OldBirthday(ctx)
	}
	return nil, fmt.Errorf("unknown Artist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artist.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artist.FieldBirthday) {
		fields = append(fields, artist.FieldBirthday)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtistMutation) ClearField(name string) error {
	switch name {
	case artist.FieldBirthday:
		m.ClearBirthday()
		return nil
	}
	return fmt.Errorf("unknown Artist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtistMutation) ResetField(name string) error {
	switch name {
	case artist.FieldName:
		m.ResetName()
		return nil
	case artist.FieldBirthday:
		m.ResetBirthday()
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtistMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.profile_picture != nil {
		edges = append(edges, artist.EdgeProfilePicture)
	}
	if m.pictures != nil {
		edges = append(edges, artist.EdgePictures)
	}
	if m.directed != nil {
		edges = append(edges, artist.EdgeDirected)
	}
	if m.acted != nil {
		edges = append(edges, artist.EdgeActed)
	}
	if m.wrote != nil {
		edges = append(edges, artist.EdgeWrote)
	}
	if m.countries != nil {
		edges = append(edges, artist.EdgeCountries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeProfilePicture:
		if id := m.profile_picture; id != nil {
			return []ent.Value{*id}
		}
	case artist.EdgePictures:
		ids := make([]ent.Value, 0, len(m.pictures))
		for id := range m.pictures {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeDirected:
		ids := make([]ent.Value, 0, len(m.directed))
		for id := range m.directed {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeActed:
		ids := make([]ent.Value, 0, len(m.acted))
		for id := range m.acted {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeWrote:
		ids := make([]ent.Value, 0, len(m.wrote))
		for id := range m.wrote {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeCountries:
		ids := make([]ent.Value, 0, len(m.countries))
		for id := range m.countries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedpictures != nil {
		edges = append(edges, artist.EdgePictures)
	}
	if m.removeddirected != nil {
		edges = append(edges, artist.EdgeDirected)
	}
	if m.removedacted != nil {
		edges = append(edges, artist.EdgeActed)
	}
	if m.removedwrote != nil {
		edges = append(edges, artist.EdgeWrote)
	}
	if m.removedcountries != nil {
		edges = append(edges, artist.EdgeCountries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgePictures:
		ids := make([]ent.Value, 0, len(m.removedpictures))
		for id := range m.removedpictures {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeDirected:
		ids := make([]ent.Value, 0, len(m.removeddirected))
		for id := range m.removeddirected {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeActed:
		ids := make([]ent.Value, 0, len(m.removedacted))
		for id := range m.removedacted {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeWrote:
		ids := make([]ent.Value, 0, len(m.removedwrote))
		for id := range m.removedwrote {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeCountries:
		ids := make([]ent.Value, 0, len(m.removedcountries))
		for id := range m.removedcountries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedprofile_picture {
		edges = append(edges, artist.EdgeProfilePicture)
	}
	if m.clearedpictures {
		edges = append(edges, artist.EdgePictures)
	}
	if m.cleareddirected {
		edges = append(edges, artist.EdgeDirected)
	}
	if m.clearedacted {
		edges = append(edges, artist.EdgeActed)
	}
	if m.clearedwrote {
		edges = append(edges, artist.EdgeWrote)
	}
	if m.clearedcountries {
		edges = append(edges, artist.EdgeCountries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtistMutation) EdgeCleared(name string) bool {
	switch name {
	case artist.EdgeProfilePicture:
		return m.clearedprofile_picture
	case artist.EdgePictures:
		return m.clearedpictures
	case artist.EdgeDirected:
		return m.cleareddirected
	case artist.EdgeActed:
		return m.clearedacted
	case artist.EdgeWrote:
		return m.clearedwrote
	case artist.EdgeCountries:
		return m.clearedcountries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtistMutation) ClearEdge(name string) error {
	switch name {
	case artist.EdgeProfilePicture:
		m.ClearProfilePicture()
		return nil
	}
	return fmt.Errorf("unknown Artist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtistMutation) ResetEdge(name string) error {
	switch name {
	case artist.EdgeProfilePicture:
		m.ResetProfilePicture()
		return nil
	case artist.EdgePictures:
		m.ResetPictures()
		return nil
	case artist.EdgeDirected:
		m.ResetDirected()
		return nil
	case artist.EdgeActed:
		m.ResetActed()
		return nil
	case artist.EdgeWrote:
		m.ResetWrote()
		return nil
	case artist.EdgeCountries:
		m.ResetCountries()
		return nil
	}
	return fmt.Errorf("unknown Artist edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	code           *string
	clearedFields  map[string]struct{}
	movies         map[int]struct{}
	removedmovies  map[int]struct{}
	clearedmovies  bool
	artists        map[int]struct{}
	removedartists map[int]struct{}
	clearedartists bool
	done           bool
	oldValue       func(context.Context) (*Country, error)
	predicates     []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// AddMovieIDs adds the "movies" edge to the Movie entity by ids.
func (m *CountryMutation) AddMovieIDs(ids ...int) {
	if m.movies == nil {
		m.movies = make(map[int]struct{})
	}
	for i := range ids {
		m.movies[ids[i]] = struct{}{}
	}
}

// ClearMovies clears the "movies" edge to the Movie entity.
func (m *CountryMutation) ClearMovies() {
	m.clearedmovies = true
}

// MoviesCleared reports if the "movies" edge to the Movie entity was cleared.
func (m *CountryMutation) MoviesCleared() bool {
	return m.clearedmovies
}

// RemoveMovieIDs removes the "movies" edge to the Movie entity by IDs.
func (m *CountryMutation) RemoveMovieIDs(ids ...int) {
	if m.removedmovies == nil {
		m.removedmovies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movies, ids[i])
		m.removedmovies[ids[i]] = struct{}{}
	}
}

// RemovedMovies returns the removed IDs of the "movies" edge to the Movie entity.
func (m *CountryMutation) RemovedMoviesIDs() (ids []int) {
	for id := range m.removedmovies {
		ids = append(ids, id)
	}
	return
}

// MoviesIDs returns the "movies" edge IDs in the mutation.
func (m *CountryMutation) MoviesIDs() (ids []int) {
	for id := range m.movies {
		ids = append(ids, id)
	}
	return
}

// ResetMovies resets all changes to the "movies" edge.
func (m *CountryMutation) ResetMovies() {
	m.movies = nil
	m.clearedmovies = false
	m.removedmovies = nil
}

// AddArtistIDs adds the "artists" edge to the Artist entity by ids.
func (m *CountryMutation) AddArtistIDs(ids ...int) {
	if m.artists == nil {
		m.artists = make(map[int]struct{})
	}
	for i := range ids {
		m.artists[ids[i]] = struct{}{}
	}
}

// ClearArtists clears the "artists" edge to the Artist entity.
func (m *CountryMutation) ClearArtists() {
	m.clearedartists = true
}

// ArtistsCleared reports if the "artists" edge to the Artist entity was cleared.
func (m *CountryMutation) ArtistsCleared() bool {
	return m.clearedartists
}

// RemoveArtistIDs removes the "artists" edge to the Artist entity by IDs.
func (m *CountryMutation) RemoveArtistIDs(ids ...int) {
	if m.removedartists == nil {
		m.removedartists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artists, ids[i])
		m.removedartists[ids[i]] = struct{}{}
	}
}

// RemovedArtists returns the removed IDs of the "artists" edge to the Artist entity.
func (m *CountryMutation) RemovedArtistsIDs() (ids []int) {
	for id := range m.removedartists {
		ids = append(ids, id)
	}
	return
}

// ArtistsIDs returns the "artists" edge IDs in the mutation.
func (m *CountryMutation) ArtistsIDs() (ids []int) {
	for id := range m.artists {
		ids = append(ids, id)
	}
	return
}

// ResetArtists resets all changes to the "artists" edge.
func (m *CountryMutation) ResetArtists() {
	m.artists = nil
	m.clearedartists = false
	m.removedartists = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldName:
		return m.Name()
	case country.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.movies != nil {
		edges = append(edges, country.EdgeMovies)
	}
	if m.artists != nil {
		edges = append(edges, country.EdgeArtists)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeMovies:
		ids := make([]ent.Value, 0, len(m.movies))
		for id := range m.movies {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeArtists:
		ids := make([]ent.Value, 0, len(m.artists))
		for id := range m.artists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmovies != nil {
		edges = append(edges, country.EdgeMovies)
	}
	if m.removedartists != nil {
		edges = append(edges, country.EdgeArtists)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeMovies:
		ids := make([]ent.Value, 0, len(m.removedmovies))
		for id := range m.removedmovies {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeArtists:
		ids := make([]ent.Value, 0, len(m.removedartists))
		for id := range m.removedartists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmovies {
		edges = append(edges, country.EdgeMovies)
	}
	if m.clearedartists {
		edges = append(edges, country.EdgeArtists)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeMovies:
		return m.clearedmovies
	case country.EdgeArtists:
		return m.clearedartists
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeMovies:
		m.ResetMovies()
		return nil
	case country.EdgeArtists:
		m.ResetArtists()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	_path                  *string
	_type                  *file.Type
	external_id            *string
	external_info_provider *string
	results                *string
	synced                 *bool
	clearedFields          map[string]struct{}
	movie                  *int
	clearedmovie           bool
	done                   bool
	oldValue               func(context.Context) (*File, error)
	predicates             []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(f file.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r file.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v file.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetExternalID sets the "external_id" field.
func (m *FileMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *FileMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *FileMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[file.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *FileMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[file.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *FileMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, file.FieldExternalID)
}

// SetExternalInfoProvider sets the "external_info_provider" field.
func (m *FileMutation) SetExternalInfoProvider(s string) {
	m.external_info_provider = &s
}

// ExternalInfoProvider returns the value of the "external_info_provider" field in the mutation.
func (m *FileMutation) ExternalInfoProvider() (r string, exists bool) {
	v := m.external_info_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalInfoProvider returns the old "external_info_provider" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExternalInfoProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalInfoProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalInfoProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalInfoProvider: %w", err)
	}
	return oldValue.ExternalInfoProvider, nil
}

// ClearExternalInfoProvider clears the value of the "external_info_provider" field.
func (m *FileMutation) ClearExternalInfoProvider() {
	m.external_info_provider = nil
	m.clearedFields[file.FieldExternalInfoProvider] = struct{}{}
}

// ExternalInfoProviderCleared returns if the "external_info_provider" field was cleared in this mutation.
func (m *FileMutation) ExternalInfoProviderCleared() bool {
	_, ok := m.clearedFields[file.FieldExternalInfoProvider]
	return ok
}

// ResetExternalInfoProvider resets all changes to the "external_info_provider" field.
func (m *FileMutation) ResetExternalInfoProvider() {
	m.external_info_provider = nil
	delete(m.clearedFields, file.FieldExternalInfoProvider)
}

// SetResults sets the "results" field.
func (m *FileMutation) SetResults(s string) {
	m.results = &s
}

// Results returns the value of the "results" field in the mutation.
func (m *FileMutation) Results() (r string, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldResults(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ClearResults clears the value of the "results" field.
func (m *FileMutation) ClearResults() {
	m.results = nil
	m.clearedFields[file.FieldResults] = struct{}{}
}

// ResultsCleared returns if the "results" field was cleared in this mutation.
func (m *FileMutation) ResultsCleared() bool {
	_, ok := m.clearedFields[file.FieldResults]
	return ok
}

// ResetResults resets all changes to the "results" field.
func (m *FileMutation) ResetResults() {
	m.results = nil
	delete(m.clearedFields, file.FieldResults)
}

// SetSynced sets the "synced" field.
func (m *FileMutation) SetSynced(b bool) {
	m.synced = &b
}

// Synced returns the value of the "synced" field in the mutation.
func (m *FileMutation) Synced() (r bool, exists bool) {
	v := m.synced
	if v == nil {
		return
	}
	return *v, true
}

// OldSynced returns the old "synced" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSynced(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSynced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSynced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSynced: %w", err)
	}
	return oldValue.Synced, nil
}

// ResetSynced resets all changes to the "synced" field.
func (m *FileMutation) ResetSynced() {
	m.synced = nil
}

// SetMovieID sets the "movie" edge to the Movie entity by id.
func (m *FileMutation) SetMovieID(id int) {
	m.movie = &id
}

// ClearMovie clears the "movie" edge to the Movie entity.
func (m *FileMutation) ClearMovie() {
	m.clearedmovie = true
}

// MovieCleared reports if the "movie" edge to the Movie entity was cleared.
func (m *FileMutation) MovieCleared() bool {
	return m.clearedmovie
}

// MovieID returns the "movie" edge ID in the mutation.
func (m *FileMutation) MovieID() (id int, exists bool) {
	if m.movie != nil {
		return *m.movie, true
	}
	return
}

// MovieIDs returns the "movie" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MovieID instead. It exists only for internal usage by the builders.
func (m *FileMutation) MovieIDs() (ids []int) {
	if id := m.movie; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMovie resets all changes to the "movie" edge.
func (m *FileMutation) ResetMovie() {
	m.movie = nil
	m.clearedmovie = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.external_id != nil {
		fields = append(fields, file.FieldExternalID)
	}
	if m.external_info_provider != nil {
		fields = append(fields, file.FieldExternalInfoProvider)
	}
	if m.results != nil {
		fields = append(fields, file.FieldResults)
	}
	if m.synced != nil {
		fields = append(fields, file.FieldSynced)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldName:
		return m.Name()
	case file.FieldPath:
		return m.Path()
	case file.FieldType:
		return m.GetType()
	case file.FieldExternalID:
		return m.ExternalID()
	case file.FieldExternalInfoProvider:
		return m.ExternalInfoProvider()
	case file.FieldResults:
		return m.Results()
	case file.FieldSynced:
		return m.Synced()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldExternalID:
		return m.OldExternalID(ctx)
	case file.FieldExternalInfoProvider:
		return m.OldExternalInfoProvider(ctx)
	case file.FieldResults:
		return m.OldResults(ctx)
	case file.FieldSynced:
		return m.OldSynced(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldType:
		v, ok := value.(file.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case file.FieldExternalInfoProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalInfoProvider(v)
		return nil
	case file.FieldResults:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	case file.FieldSynced:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSynced(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldExternalID) {
		fields = append(fields, file.FieldExternalID)
	}
	if m.FieldCleared(file.FieldExternalInfoProvider) {
		fields = append(fields, file.FieldExternalInfoProvider)
	}
	if m.FieldCleared(file.FieldResults) {
		fields = append(fields, file.FieldResults)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldExternalID:
		m.ClearExternalID()
		return nil
	case file.FieldExternalInfoProvider:
		m.ClearExternalInfoProvider()
		return nil
	case file.FieldResults:
		m.ClearResults()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldExternalID:
		m.ResetExternalID()
		return nil
	case file.FieldExternalInfoProvider:
		m.ResetExternalInfoProvider()
		return nil
	case file.FieldResults:
		m.ResetResults()
		return nil
	case file.FieldSynced:
		m.ResetSynced()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.movie != nil {
		edges = append(edges, file.EdgeMovie)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeMovie:
		if id := m.movie; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmovie {
		edges = append(edges, file.EdgeMovie)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeMovie:
		return m.clearedmovie
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeMovie:
		m.ClearMovie()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeMovie:
		m.ResetMovie()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// MovieMutation represents an operation that mutates the Movie nodes in the graph.
type MovieMutation struct {
	config
	op               Op
	typ              string
	id               *int
	title            *string
	original_title   *string
	release_date     *time.Time
	plot             *string
	duration         *int
	addduration      *int
	watched          *bool
	clearedFields    map[string]struct{}
	file             *int
	clearedfile      bool
	ratings          map[int]struct{}
	removedratings   map[int]struct{}
	clearedratings   bool
	poster           *int
	clearedposter    bool
	fanart           map[int]struct{}
	removedfanart    map[int]struct{}
	clearedfanart    bool
	cast             map[int]struct{}
	removedcast      map[int]struct{}
	clearedcast      bool
	directors        map[int]struct{}
	removeddirectors map[int]struct{}
	cleareddirectors bool
	writers          map[int]struct{}
	removedwriters   map[int]struct{}
	clearedwriters   bool
	genres           map[int]struct{}
	removedgenres    map[int]struct{}
	clearedgenres    bool
	countries        map[int]struct{}
	removedcountries map[int]struct{}
	clearedcountries bool
	done             bool
	oldValue         func(context.Context) (*Movie, error)
	predicates       []predicate.Movie
}

var _ ent.Mutation = (*MovieMutation)(nil)

// movieOption allows management of the mutation configuration using functional options.
type movieOption func(*MovieMutation)

// newMovieMutation creates new mutation for the Movie entity.
func newMovieMutation(c config, op Op, opts ...movieOption) *MovieMutation {
	m := &MovieMutation{
		config:        c,
		op:            op,
		typ:           TypeMovie,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMovieID sets the ID field of the mutation.
func withMovieID(id int) movieOption {
	return func(m *MovieMutation) {
		var (
			err   error
			once  sync.Once
			value *Movie
		)
		m.oldValue = func(ctx context.Context) (*Movie, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Movie.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMovie sets the old Movie of the mutation.
func withMovie(node *Movie) movieOption {
	return func(m *MovieMutation) {
		m.oldValue = func(context.Context) (*Movie, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MovieMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MovieMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MovieMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MovieMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Movie.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *MovieMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MovieMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MovieMutation) ResetTitle() {
	m.title = nil
}

// SetOriginalTitle sets the "original_title" field.
func (m *MovieMutation) SetOriginalTitle(s string) {
	m.original_title = &s
}

// OriginalTitle returns the value of the "original_title" field in the mutation.
func (m *MovieMutation) OriginalTitle() (r string, exists bool) {
	v := m.original_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalTitle returns the old "original_title" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldOriginalTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalTitle: %w", err)
	}
	return oldValue.OriginalTitle, nil
}

// ClearOriginalTitle clears the value of the "original_title" field.
func (m *MovieMutation) ClearOriginalTitle() {
	m.original_title = nil
	m.clearedFields[movie.FieldOriginalTitle] = struct{}{}
}

// OriginalTitleCleared returns if the "original_title" field was cleared in this mutation.
func (m *MovieMutation) OriginalTitleCleared() bool {
	_, ok := m.clearedFields[movie.FieldOriginalTitle]
	return ok
}

// ResetOriginalTitle resets all changes to the "original_title" field.
func (m *MovieMutation) ResetOriginalTitle() {
	m.original_title = nil
	delete(m.clearedFields, movie.FieldOriginalTitle)
}

// SetReleaseDate sets the "release_date" field.
func (m *MovieMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *MovieMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *MovieMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[movie.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *MovieMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[movie.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *MovieMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, movie.FieldReleaseDate)
}

// SetPlot sets the "plot" field.
func (m *MovieMutation) SetPlot(s string) {
	m.plot = &s
}

// Plot returns the value of the "plot" field in the mutation.
func (m *MovieMutation) Plot() (r string, exists bool) {
	v := m.plot
	if v == nil {
		return
	}
	return *v, true
}

// OldPlot returns the old "plot" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldPlot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlot: %w", err)
	}
	return oldValue.Plot, nil
}

// ClearPlot clears the value of the "plot" field.
func (m *MovieMutation) ClearPlot() {
	m.plot = nil
	m.clearedFields[movie.FieldPlot] = struct{}{}
}

// PlotCleared returns if the "plot" field was cleared in this mutation.
func (m *MovieMutation) PlotCleared() bool {
	_, ok := m.clearedFields[movie.FieldPlot]
	return ok
}

// ResetPlot resets all changes to the "plot" field.
func (m *MovieMutation) ResetPlot() {
	m.plot = nil
	delete(m.clearedFields, movie.FieldPlot)
}

// SetDuration sets the "duration" field.
func (m *MovieMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MovieMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *MovieMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *MovieMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *MovieMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[movie.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *MovieMutation) DurationCleared() bool {
	_, ok := m.clearedFields[movie.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *MovieMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, movie.FieldDuration)
}

// SetWatched sets the "watched" field.
func (m *MovieMutation) SetWatched(b bool) {
	m.watched = &b
}

// Watched returns the value of the "watched" field in the mutation.
func (m *MovieMutation) Watched() (r bool, exists bool) {
	v := m.watched
	if v == nil {
		return
	}
	return *v, true
}

// OldWatched returns the old "watched" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldWatched(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatched is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatched requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatched: %w", err)
	}
	return oldValue.Watched, nil
}

// ResetWatched resets all changes to the "watched" field.
func (m *MovieMutation) ResetWatched() {
	m.watched = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *MovieMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *MovieMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *MovieMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *MovieMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *MovieMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *MovieMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// AddRatingIDs adds the "ratings" edge to the Rating entity by ids.
func (m *MovieMutation) AddRatingIDs(ids ...int) {
	if m.ratings == nil {
		m.ratings = make(map[int]struct{})
	}
	for i := range ids {
		m.ratings[ids[i]] = struct{}{}
	}
}

// ClearRatings clears the "ratings" edge to the Rating entity.
func (m *MovieMutation) ClearRatings() {
	m.clearedratings = true
}

// RatingsCleared reports if the "ratings" edge to the Rating entity was cleared.
func (m *MovieMutation) RatingsCleared() bool {
	return m.clearedratings
}

// RemoveRatingIDs removes the "ratings" edge to the Rating entity by IDs.
func (m *MovieMutation) RemoveRatingIDs(ids ...int) {
	if m.removedratings == nil {
		m.removedratings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ratings, ids[i])
		m.removedratings[ids[i]] = struct{}{}
	}
}

// RemovedRatings returns the removed IDs of the "ratings" edge to the Rating entity.
func (m *MovieMutation) RemovedRatingsIDs() (ids []int) {
	for id := range m.removedratings {
		ids = append(ids, id)
	}
	return
}

// RatingsIDs returns the "ratings" edge IDs in the mutation.
func (m *MovieMutation) RatingsIDs() (ids []int) {
	for id := range m.ratings {
		ids = append(ids, id)
	}
	return
}

// ResetRatings resets all changes to the "ratings" edge.
func (m *MovieMutation) ResetRatings() {
	m.ratings = nil
	m.clearedratings = false
	m.removedratings = nil
}

// SetPosterID sets the "poster" edge to the Picture entity by id.
func (m *MovieMutation) SetPosterID(id int) {
	m.poster = &id
}

// ClearPoster clears the "poster" edge to the Picture entity.
func (m *MovieMutation) ClearPoster() {
	m.clearedposter = true
}

// PosterCleared reports if the "poster" edge to the Picture entity was cleared.
func (m *MovieMutation) PosterCleared() bool {
	return m.clearedposter
}

// PosterID returns the "poster" edge ID in the mutation.
func (m *MovieMutation) PosterID() (id int, exists bool) {
	if m.poster != nil {
		return *m.poster, true
	}
	return
}

// PosterIDs returns the "poster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PosterID instead. It exists only for internal usage by the builders.
func (m *MovieMutation) PosterIDs() (ids []int) {
	if id := m.poster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPoster resets all changes to the "poster" edge.
func (m *MovieMutation) ResetPoster() {
	m.poster = nil
	m.clearedposter = false
}

// AddFanartIDs adds the "fanart" edge to the Picture entity by ids.
func (m *MovieMutation) AddFanartIDs(ids ...int) {
	if m.fanart == nil {
		m.fanart = make(map[int]struct{})
	}
	for i := range ids {
		m.fanart[ids[i]] = struct{}{}
	}
}

// ClearFanart clears the "fanart" edge to the Picture entity.
func (m *MovieMutation) ClearFanart() {
	m.clearedfanart = true
}

// FanartCleared reports if the "fanart" edge to the Picture entity was cleared.
func (m *MovieMutation) FanartCleared() bool {
	return m.clearedfanart
}

// RemoveFanartIDs removes the "fanart" edge to the Picture entity by IDs.
func (m *MovieMutation) RemoveFanartIDs(ids ...int) {
	if m.removedfanart == nil {
		m.removedfanart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fanart, ids[i])
		m.removedfanart[ids[i]] = struct{}{}
	}
}

// RemovedFanart returns the removed IDs of the "fanart" edge to the Picture entity.
func (m *MovieMutation) RemovedFanartIDs() (ids []int) {
	for id := range m.removedfanart {
		ids = append(ids, id)
	}
	return
}

// FanartIDs returns the "fanart" edge IDs in the mutation.
func (m *MovieMutation) FanartIDs() (ids []int) {
	for id := range m.fanart {
		ids = append(ids, id)
	}
	return
}

// ResetFanart resets all changes to the "fanart" edge.
func (m *MovieMutation) ResetFanart() {
	m.fanart = nil
	m.clearedfanart = false
	m.removedfanart = nil
}

// AddCastIDs adds the "cast" edge to the Artist entity by ids.
func (m *MovieMutation) AddCastIDs(ids ...int) {
	if m.cast == nil {
		m.cast = make(map[int]struct{})
	}
	for i := range ids {
		m.cast[ids[i]] = struct{}{}
	}
}

// ClearCast clears the "cast" edge to the Artist entity.
func (m *MovieMutation) ClearCast() {
	m.clearedcast = true
}

// CastCleared reports if the "cast" edge to the Artist entity was cleared.
func (m *MovieMutation) CastCleared() bool {
	return m.clearedcast
}

// RemoveCastIDs removes the "cast" edge to the Artist entity by IDs.
func (m *MovieMutation) RemoveCastIDs(ids ...int) {
	if m.removedcast == nil {
		m.removedcast = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cast, ids[i])
		m.removedcast[ids[i]] = struct{}{}
	}
}

// RemovedCast returns the removed IDs of the "cast" edge to the Artist entity.
func (m *MovieMutation) RemovedCastIDs() (ids []int) {
	for id := range m.removedcast {
		ids = append(ids, id)
	}
	return
}

// CastIDs returns the "cast" edge IDs in the mutation.
func (m *MovieMutation) CastIDs() (ids []int) {
	for id := range m.cast {
		ids = append(ids, id)
	}
	return
}

// ResetCast resets all changes to the "cast" edge.
func (m *MovieMutation) ResetCast() {
	m.cast = nil
	m.clearedcast = false
	m.removedcast = nil
}

// AddDirectorIDs adds the "directors" edge to the Artist entity by ids.
func (m *MovieMutation) AddDirectorIDs(ids ...int) {
	if m.directors == nil {
		m.directors = make(map[int]struct{})
	}
	for i := range ids {
		m.directors[ids[i]] = struct{}{}
	}
}

// ClearDirectors clears the "directors" edge to the Artist entity.
func (m *MovieMutation) ClearDirectors() {
	m.cleareddirectors = true
}

// DirectorsCleared reports if the "directors" edge to the Artist entity was cleared.
func (m *MovieMutation) DirectorsCleared() bool {
	return m.cleareddirectors
}

// RemoveDirectorIDs removes the "directors" edge to the Artist entity by IDs.
func (m *MovieMutation) RemoveDirectorIDs(ids ...int) {
	if m.removeddirectors == nil {
		m.removeddirectors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.directors, ids[i])
		m.removeddirectors[ids[i]] = struct{}{}
	}
}

// RemovedDirectors returns the removed IDs of the "directors" edge to the Artist entity.
func (m *MovieMutation) RemovedDirectorsIDs() (ids []int) {
	for id := range m.removeddirectors {
		ids = append(ids, id)
	}
	return
}

// DirectorsIDs returns the "directors" edge IDs in the mutation.
func (m *MovieMutation) DirectorsIDs() (ids []int) {
	for id := range m.directors {
		ids = append(ids, id)
	}
	return
}

// ResetDirectors resets all changes to the "directors" edge.
func (m *MovieMutation) ResetDirectors() {
	m.directors = nil
	m.cleareddirectors = false
	m.removeddirectors = nil
}

// AddWriterIDs adds the "writers" edge to the Artist entity by ids.
func (m *MovieMutation) AddWriterIDs(ids ...int) {
	if m.writers == nil {
		m.writers = make(map[int]struct{})
	}
	for i := range ids {
		m.writers[ids[i]] = struct{}{}
	}
}

// ClearWriters clears the "writers" edge to the Artist entity.
func (m *MovieMutation) ClearWriters() {
	m.clearedwriters = true
}

// WritersCleared reports if the "writers" edge to the Artist entity was cleared.
func (m *MovieMutation) WritersCleared() bool {
	return m.clearedwriters
}

// RemoveWriterIDs removes the "writers" edge to the Artist entity by IDs.
func (m *MovieMutation) RemoveWriterIDs(ids ...int) {
	if m.removedwriters == nil {
		m.removedwriters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.writers, ids[i])
		m.removedwriters[ids[i]] = struct{}{}
	}
}

// RemovedWriters returns the removed IDs of the "writers" edge to the Artist entity.
func (m *MovieMutation) RemovedWritersIDs() (ids []int) {
	for id := range m.removedwriters {
		ids = append(ids, id)
	}
	return
}

// WritersIDs returns the "writers" edge IDs in the mutation.
func (m *MovieMutation) WritersIDs() (ids []int) {
	for id := range m.writers {
		ids = append(ids, id)
	}
	return
}

// ResetWriters resets all changes to the "writers" edge.
func (m *MovieMutation) ResetWriters() {
	m.writers = nil
	m.clearedwriters = false
	m.removedwriters = nil
}

// AddGenreIDs adds the "genres" edge to the MovieGenre entity by ids.
func (m *MovieMutation) AddGenreIDs(ids ...int) {
	if m.genres == nil {
		m.genres = make(map[int]struct{})
	}
	for i := range ids {
		m.genres[ids[i]] = struct{}{}
	}
}

// ClearGenres clears the "genres" edge to the MovieGenre entity.
func (m *MovieMutation) ClearGenres() {
	m.clearedgenres = true
}

// GenresCleared reports if the "genres" edge to the MovieGenre entity was cleared.
func (m *MovieMutation) GenresCleared() bool {
	return m.clearedgenres
}

// RemoveGenreIDs removes the "genres" edge to the MovieGenre entity by IDs.
func (m *MovieMutation) RemoveGenreIDs(ids ...int) {
	if m.removedgenres == nil {
		m.removedgenres = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.genres, ids[i])
		m.removedgenres[ids[i]] = struct{}{}
	}
}

// RemovedGenres returns the removed IDs of the "genres" edge to the MovieGenre entity.
func (m *MovieMutation) RemovedGenresIDs() (ids []int) {
	for id := range m.removedgenres {
		ids = append(ids, id)
	}
	return
}

// GenresIDs returns the "genres" edge IDs in the mutation.
func (m *MovieMutation) GenresIDs() (ids []int) {
	for id := range m.genres {
		ids = append(ids, id)
	}
	return
}

// ResetGenres resets all changes to the "genres" edge.
func (m *MovieMutation) ResetGenres() {
	m.genres = nil
	m.clearedgenres = false
	m.removedgenres = nil
}

// AddCountryIDs adds the "countries" edge to the Country entity by ids.
func (m *MovieMutation) AddCountryIDs(ids ...int) {
	if m.countries == nil {
		m.countries = make(map[int]struct{})
	}
	for i := range ids {
		m.countries[ids[i]] = struct{}{}
	}
}

// ClearCountries clears the "countries" edge to the Country entity.
func (m *MovieMutation) ClearCountries() {
	m.clearedcountries = true
}

// CountriesCleared reports if the "countries" edge to the Country entity was cleared.
func (m *MovieMutation) CountriesCleared() bool {
	return m.clearedcountries
}

// RemoveCountryIDs removes the "countries" edge to the Country entity by IDs.
func (m *MovieMutation) RemoveCountryIDs(ids ...int) {
	if m.removedcountries == nil {
		m.removedcountries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.countries, ids[i])
		m.removedcountries[ids[i]] = struct{}{}
	}
}

// RemovedCountries returns the removed IDs of the "countries" edge to the Country entity.
func (m *MovieMutation) RemovedCountriesIDs() (ids []int) {
	for id := range m.removedcountries {
		ids = append(ids, id)
	}
	return
}

// CountriesIDs returns the "countries" edge IDs in the mutation.
func (m *MovieMutation) CountriesIDs() (ids []int) {
	for id := range m.countries {
		ids = append(ids, id)
	}
	return
}

// ResetCountries resets all changes to the "countries" edge.
func (m *MovieMutation) ResetCountries() {
	m.countries = nil
	m.clearedcountries = false
	m.removedcountries = nil
}

// Where appends a list predicates to the MovieMutation builder.
func (m *MovieMutation) Where(ps ...predicate.Movie) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MovieMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Movie).
func (m *MovieMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MovieMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, movie.FieldTitle)
	}
	if m.original_title != nil {
		fields = append(fields, movie.FieldOriginalTitle)
	}
	if m.release_date != nil {
		fields = append(fields, movie.FieldReleaseDate)
	}
	if m.plot != nil {
		fields = append(fields, movie.FieldPlot)
	}
	if m.duration != nil {
		fields = append(fields, movie.FieldDuration)
	}
	if m.watched != nil {
		fields = append(fields, movie.FieldWatched)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MovieMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case movie.FieldTitle:
		return m.Title()
	case movie.FieldOriginalTitle:
		return m.OriginalTitle()
	case movie.FieldReleaseDate:
		return m.ReleaseDate()
	case movie.FieldPlot:
		return m.Plot()
	case movie.FieldDuration:
		return m.Duration()
	case movie.FieldWatched:
		return m.Watched()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MovieMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case movie.FieldTitle:
		return m.OldTitle(ctx)
	case movie.FieldOriginalTitle:
		return m.OldOriginalTitle(ctx)
	case movie.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case movie.FieldPlot:
		return m.OldPlot(ctx)
	case movie.FieldDuration:
		return m.OldDuration(ctx)
	case movie.FieldWatched:
		return m.OldWatched(ctx)
	}
	return nil, fmt.Errorf("unknown Movie field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieMutation) SetField(name string, value ent.Value) error {
	switch name {
	case movie.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case movie.FieldOriginalTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalTitle(v)
		return nil
	case movie.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case movie.FieldPlot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlot(v)
		return nil
	case movie.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case movie.FieldWatched:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatched(v)
		return nil
	}
	return fmt.Errorf("unknown Movie field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MovieMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, movie.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MovieMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case movie.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieMutation) AddField(name string, value ent.Value) error {
	switch name {
	case movie.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Movie numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MovieMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(movie.FieldOriginalTitle) {
		fields = append(fields, movie.FieldOriginalTitle)
	}
	if m.FieldCleared(movie.FieldReleaseDate) {
		fields = append(fields, movie.FieldReleaseDate)
	}
	if m.FieldCleared(movie.FieldPlot) {
		fields = append(fields, movie.FieldPlot)
	}
	if m.FieldCleared(movie.FieldDuration) {
		fields = append(fields, movie.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MovieMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MovieMutation) ClearField(name string) error {
	switch name {
	case movie.FieldOriginalTitle:
		m.ClearOriginalTitle()
		return nil
	case movie.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case movie.FieldPlot:
		m.ClearPlot()
		return nil
	case movie.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown Movie nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MovieMutation) ResetField(name string) error {
	switch name {
	case movie.FieldTitle:
		m.ResetTitle()
		return nil
	case movie.FieldOriginalTitle:
		m.ResetOriginalTitle()
		return nil
	case movie.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case movie.FieldPlot:
		m.ResetPlot()
		return nil
	case movie.FieldDuration:
		m.ResetDuration()
		return nil
	case movie.FieldWatched:
		m.ResetWatched()
		return nil
	}
	return fmt.Errorf("unknown Movie field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MovieMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.file != nil {
		edges = append(edges, movie.EdgeFile)
	}
	if m.ratings != nil {
		edges = append(edges, movie.EdgeRatings)
	}
	if m.poster != nil {
		edges = append(edges, movie.EdgePoster)
	}
	if m.fanart != nil {
		edges = append(edges, movie.EdgeFanart)
	}
	if m.cast != nil {
		edges = append(edges, movie.EdgeCast)
	}
	if m.directors != nil {
		edges = append(edges, movie.EdgeDirectors)
	}
	if m.writers != nil {
		edges = append(edges, movie.EdgeWriters)
	}
	if m.genres != nil {
		edges = append(edges, movie.EdgeGenres)
	}
	if m.countries != nil {
		edges = append(edges, movie.EdgeCountries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MovieMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case movie.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case movie.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.ratings))
		for id := range m.ratings {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgePoster:
		if id := m.poster; id != nil {
			return []ent.Value{*id}
		}
	case movie.EdgeFanart:
		ids := make([]ent.Value, 0, len(m.fanart))
		for id := range m.fanart {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeCast:
		ids := make([]ent.Value, 0, len(m.cast))
		for id := range m.cast {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeDirectors:
		ids := make([]ent.Value, 0, len(m.directors))
		for id := range m.directors {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeWriters:
		ids := make([]ent.Value, 0, len(m.writers))
		for id := range m.writers {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeGenres:
		ids := make([]ent.Value, 0, len(m.genres))
		for id := range m.genres {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeCountries:
		ids := make([]ent.Value, 0, len(m.countries))
		for id := range m.countries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MovieMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedratings != nil {
		edges = append(edges, movie.EdgeRatings)
	}
	if m.removedfanart != nil {
		edges = append(edges, movie.EdgeFanart)
	}
	if m.removedcast != nil {
		edges = append(edges, movie.EdgeCast)
	}
	if m.removeddirectors != nil {
		edges = append(edges, movie.EdgeDirectors)
	}
	if m.removedwriters != nil {
		edges = append(edges, movie.EdgeWriters)
	}
	if m.removedgenres != nil {
		edges = append(edges, movie.EdgeGenres)
	}
	if m.removedcountries != nil {
		edges = append(edges, movie.EdgeCountries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MovieMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case movie.EdgeRatings:
		ids := make([]ent.Value, 0, len(m.removedratings))
		for id := range m.removedratings {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeFanart:
		ids := make([]ent.Value, 0, len(m.removedfanart))
		for id := range m.removedfanart {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeCast:
		ids := make([]ent.Value, 0, len(m.removedcast))
		for id := range m.removedcast {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeDirectors:
		ids := make([]ent.Value, 0, len(m.removeddirectors))
		for id := range m.removeddirectors {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeWriters:
		ids := make([]ent.Value, 0, len(m.removedwriters))
		for id := range m.removedwriters {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeGenres:
		ids := make([]ent.Value, 0, len(m.removedgenres))
		for id := range m.removedgenres {
			ids = append(ids, id)
		}
		return ids
	case movie.EdgeCountries:
		ids := make([]ent.Value, 0, len(m.removedcountries))
		for id := range m.removedcountries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MovieMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedfile {
		edges = append(edges, movie.EdgeFile)
	}
	if m.clearedratings {
		edges = append(edges, movie.EdgeRatings)
	}
	if m.clearedposter {
		edges = append(edges, movie.EdgePoster)
	}
	if m.clearedfanart {
		edges = append(edges, movie.EdgeFanart)
	}
	if m.clearedcast {
		edges = append(edges, movie.EdgeCast)
	}
	if m.cleareddirectors {
		edges = append(edges, movie.EdgeDirectors)
	}
	if m.clearedwriters {
		edges = append(edges, movie.EdgeWriters)
	}
	if m.clearedgenres {
		edges = append(edges, movie.EdgeGenres)
	}
	if m.clearedcountries {
		edges = append(edges, movie.EdgeCountries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MovieMutation) EdgeCleared(name string) bool {
	switch name {
	case movie.EdgeFile:
		return m.clearedfile
	case movie.EdgeRatings:
		return m.clearedratings
	case movie.EdgePoster:
		return m.clearedposter
	case movie.EdgeFanart:
		return m.clearedfanart
	case movie.EdgeCast:
		return m.clearedcast
	case movie.EdgeDirectors:
		return m.cleareddirectors
	case movie.EdgeWriters:
		return m.clearedwriters
	case movie.EdgeGenres:
		return m.clearedgenres
	case movie.EdgeCountries:
		return m.clearedcountries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MovieMutation) ClearEdge(name string) error {
	switch name {
	case movie.EdgeFile:
		m.ClearFile()
		return nil
	case movie.EdgePoster:
		m.ClearPoster()
		return nil
	}
	return fmt.Errorf("unknown Movie unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MovieMutation) ResetEdge(name string) error {
	switch name {
	case movie.EdgeFile:
		m.ResetFile()
		return nil
	case movie.EdgeRatings:
		m.ResetRatings()
		return nil
	case movie.EdgePoster:
		m.ResetPoster()
		return nil
	case movie.EdgeFanart:
		m.ResetFanart()
		return nil
	case movie.EdgeCast:
		m.ResetCast()
		return nil
	case movie.EdgeDirectors:
		m.ResetDirectors()
		return nil
	case movie.EdgeWriters:
		m.ResetWriters()
		return nil
	case movie.EdgeGenres:
		m.ResetGenres()
		return nil
	case movie.EdgeCountries:
		m.ResetCountries()
		return nil
	}
	return fmt.Errorf("unknown Movie edge %s", name)
}

// MovieGenreMutation represents an operation that mutates the MovieGenre nodes in the graph.
type MovieGenreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	movies        map[int]struct{}
	removedmovies map[int]struct{}
	clearedmovies bool
	done          bool
	oldValue      func(context.Context) (*MovieGenre, error)
	predicates    []predicate.MovieGenre
}

var _ ent.Mutation = (*MovieGenreMutation)(nil)

// moviegenreOption allows management of the mutation configuration using functional options.
type moviegenreOption func(*MovieGenreMutation)

// newMovieGenreMutation creates new mutation for the MovieGenre entity.
func newMovieGenreMutation(c config, op Op, opts ...moviegenreOption) *MovieGenreMutation {
	m := &MovieGenreMutation{
		config:        c,
		op:            op,
		typ:           TypeMovieGenre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMovieGenreID sets the ID field of the mutation.
func withMovieGenreID(id int) moviegenreOption {
	return func(m *MovieGenreMutation) {
		var (
			err   error
			once  sync.Once
			value *MovieGenre
		)
		m.oldValue = func(ctx context.Context) (*MovieGenre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MovieGenre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMovieGenre sets the old MovieGenre of the mutation.
func withMovieGenre(node *MovieGenre) moviegenreOption {
	return func(m *MovieGenreMutation) {
		m.oldValue = func(context.Context) (*MovieGenre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MovieGenreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MovieGenreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MovieGenreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MovieGenreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MovieGenre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MovieGenreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MovieGenreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MovieGenre entity.
// If the MovieGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieGenreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MovieGenreMutation) ResetName() {
	m.name = nil
}

// AddMovieIDs adds the "movies" edge to the Movie entity by ids.
func (m *MovieGenreMutation) AddMovieIDs(ids ...int) {
	if m.movies == nil {
		m.movies = make(map[int]struct{})
	}
	for i := range ids {
		m.movies[ids[i]] = struct{}{}
	}
}

// ClearMovies clears the "movies" edge to the Movie entity.
func (m *MovieGenreMutation) ClearMovies() {
	m.clearedmovies = true
}

// MoviesCleared reports if the "movies" edge to the Movie entity was cleared.
func (m *MovieGenreMutation) MoviesCleared() bool {
	return m.clearedmovies
}

// RemoveMovieIDs removes the "movies" edge to the Movie entity by IDs.
func (m *MovieGenreMutation) RemoveMovieIDs(ids ...int) {
	if m.removedmovies == nil {
		m.removedmovies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movies, ids[i])
		m.removedmovies[ids[i]] = struct{}{}
	}
}

// RemovedMovies returns the removed IDs of the "movies" edge to the Movie entity.
func (m *MovieGenreMutation) RemovedMoviesIDs() (ids []int) {
	for id := range m.removedmovies {
		ids = append(ids, id)
	}
	return
}

// MoviesIDs returns the "movies" edge IDs in the mutation.
func (m *MovieGenreMutation) MoviesIDs() (ids []int) {
	for id := range m.movies {
		ids = append(ids, id)
	}
	return
}

// ResetMovies resets all changes to the "movies" edge.
func (m *MovieGenreMutation) ResetMovies() {
	m.movies = nil
	m.clearedmovies = false
	m.removedmovies = nil
}

// Where appends a list predicates to the MovieGenreMutation builder.
func (m *MovieGenreMutation) Where(ps ...predicate.MovieGenre) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MovieGenreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MovieGenre).
func (m *MovieGenreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MovieGenreMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, moviegenre.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MovieGenreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moviegenre.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MovieGenreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moviegenre.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MovieGenre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieGenreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moviegenre.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MovieGenre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MovieGenreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MovieGenreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieGenreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MovieGenre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MovieGenreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MovieGenreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MovieGenreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MovieGenre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MovieGenreMutation) ResetField(name string) error {
	switch name {
	case moviegenre.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MovieGenre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MovieGenreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.movies != nil {
		edges = append(edges, moviegenre.EdgeMovies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MovieGenreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moviegenre.EdgeMovies:
		ids := make([]ent.Value, 0, len(m.movies))
		for id := range m.movies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MovieGenreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmovies != nil {
		edges = append(edges, moviegenre.EdgeMovies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MovieGenreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case moviegenre.EdgeMovies:
		ids := make([]ent.Value, 0, len(m.removedmovies))
		for id := range m.removedmovies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MovieGenreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmovies {
		edges = append(edges, moviegenre.EdgeMovies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MovieGenreMutation) EdgeCleared(name string) bool {
	switch name {
	case moviegenre.EdgeMovies:
		return m.clearedmovies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MovieGenreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MovieGenre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MovieGenreMutation) ResetEdge(name string) error {
	switch name {
	case moviegenre.EdgeMovies:
		m.ResetMovies()
		return nil
	}
	return fmt.Errorf("unknown MovieGenre edge %s", name)
}

// PictureMutation represents an operation that mutates the Picture nodes in the graph.
type PictureMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	filename      *string
	_path         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Picture, error)
	predicates    []predicate.Picture
}

var _ ent.Mutation = (*PictureMutation)(nil)

// pictureOption allows management of the mutation configuration using functional options.
type pictureOption func(*PictureMutation)

// newPictureMutation creates new mutation for the Picture entity.
func newPictureMutation(c config, op Op, opts ...pictureOption) *PictureMutation {
	m := &PictureMutation{
		config:        c,
		op:            op,
		typ:           TypePicture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPictureID sets the ID field of the mutation.
func withPictureID(id int) pictureOption {
	return func(m *PictureMutation) {
		var (
			err   error
			once  sync.Once
			value *Picture
		)
		m.oldValue = func(ctx context.Context) (*Picture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Picture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPicture sets the old Picture of the mutation.
func withPicture(node *Picture) pictureOption {
	return func(m *PictureMutation) {
		m.oldValue = func(context.Context) (*Picture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PictureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PictureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PictureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PictureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Picture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PictureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PictureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Picture entity.
// If the Picture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PictureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PictureMutation) ClearName() {
	m.name = nil
	m.clearedFields[picture.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PictureMutation) NameCleared() bool {
	_, ok := m.clearedFields[picture.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PictureMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, picture.FieldName)
}

// SetFilename sets the "filename" field.
func (m *PictureMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *PictureMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Picture entity.
// If the Picture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PictureMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *PictureMutation) ResetFilename() {
	m.filename = nil
}

// SetPath sets the "path" field.
func (m *PictureMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *PictureMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Picture entity.
// If the Picture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PictureMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *PictureMutation) ResetPath() {
	m._path = nil
}

// Where appends a list predicates to the PictureMutation builder.
func (m *PictureMutation) Where(ps ...predicate.Picture) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PictureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Picture).
func (m *PictureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PictureMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, picture.FieldName)
	}
	if m.filename != nil {
		fields = append(fields, picture.FieldFilename)
	}
	if m._path != nil {
		fields = append(fields, picture.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PictureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case picture.FieldName:
		return m.Name()
	case picture.FieldFilename:
		return m.Filename()
	case picture.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PictureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case picture.FieldName:
		return m.OldName(ctx)
	case picture.FieldFilename:
		return m.OldFilename(ctx)
	case picture.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Picture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PictureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case picture.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case picture.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case picture.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Picture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PictureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PictureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PictureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Picture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PictureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(picture.FieldName) {
		fields = append(fields, picture.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PictureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PictureMutation) ClearField(name string) error {
	switch name {
	case picture.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Picture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PictureMutation) ResetField(name string) error {
	switch name {
	case picture.FieldName:
		m.ResetName()
		return nil
	case picture.FieldFilename:
		m.ResetFilename()
		return nil
	case picture.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Picture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PictureMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PictureMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PictureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PictureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PictureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PictureMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PictureMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Picture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PictureMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Picture edge %s", name)
}

// RatingMutation represents an operation that mutates the Rating nodes in the graph.
type RatingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	origin               *string
	original_rating      *string
	normalized_rating    *int
	addnormalized_rating *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Rating, error)
	predicates           []predicate.Rating
}

var _ ent.Mutation = (*RatingMutation)(nil)

// ratingOption allows management of the mutation configuration using functional options.
type ratingOption func(*RatingMutation)

// newRatingMutation creates new mutation for the Rating entity.
func newRatingMutation(c config, op Op, opts ...ratingOption) *RatingMutation {
	m := &RatingMutation{
		config:        c,
		op:            op,
		typ:           TypeRating,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRatingID sets the ID field of the mutation.
func withRatingID(id int) ratingOption {
	return func(m *RatingMutation) {
		var (
			err   error
			once  sync.Once
			value *Rating
		)
		m.oldValue = func(ctx context.Context) (*Rating, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rating.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRating sets the old Rating of the mutation.
func withRating(node *Rating) ratingOption {
	return func(m *RatingMutation) {
		m.oldValue = func(context.Context) (*Rating, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RatingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RatingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RatingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RatingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rating.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrigin sets the "origin" field.
func (m *RatingMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *RatingMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Rating entity.
// If the Rating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RatingMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *RatingMutation) ResetOrigin() {
	m.origin = nil
}

// SetOriginalRating sets the "original_rating" field.
func (m *RatingMutation) SetOriginalRating(s string) {
	m.original_rating = &s
}

// OriginalRating returns the value of the "original_rating" field in the mutation.
func (m *RatingMutation) OriginalRating() (r string, exists bool) {
	v := m.original_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalRating returns the old "original_rating" field's value of the Rating entity.
// If the Rating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RatingMutation) OldOriginalRating(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalRating: %w", err)
	}
	return oldValue.OriginalRating, nil
}

// ResetOriginalRating resets all changes to the "original_rating" field.
func (m *RatingMutation) ResetOriginalRating() {
	m.original_rating = nil
}

// SetNormalizedRating sets the "normalized_rating" field.
func (m *RatingMutation) SetNormalizedRating(i int) {
	m.normalized_rating = &i
	m.addnormalized_rating = nil
}

// NormalizedRating returns the value of the "normalized_rating" field in the mutation.
func (m *RatingMutation) NormalizedRating() (r int, exists bool) {
	v := m.normalized_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalizedRating returns the old "normalized_rating" field's value of the Rating entity.
// If the Rating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RatingMutation) OldNormalizedRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalizedRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalizedRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalizedRating: %w", err)
	}
	return oldValue.NormalizedRating, nil
}

// AddNormalizedRating adds i to the "normalized_rating" field.
func (m *RatingMutation) AddNormalizedRating(i int) {
	if m.addnormalized_rating != nil {
		*m.addnormalized_rating += i
	} else {
		m.addnormalized_rating = &i
	}
}

// AddedNormalizedRating returns the value that was added to the "normalized_rating" field in this mutation.
func (m *RatingMutation) AddedNormalizedRating() (r int, exists bool) {
	v := m.addnormalized_rating
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalizedRating resets all changes to the "normalized_rating" field.
func (m *RatingMutation) ResetNormalizedRating() {
	m.normalized_rating = nil
	m.addnormalized_rating = nil
}

// Where appends a list predicates to the RatingMutation builder.
func (m *RatingMutation) Where(ps ...predicate.Rating) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RatingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rating).
func (m *RatingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RatingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.origin != nil {
		fields = append(fields, rating.FieldOrigin)
	}
	if m.original_rating != nil {
		fields = append(fields, rating.FieldOriginalRating)
	}
	if m.normalized_rating != nil {
		fields = append(fields, rating.FieldNormalizedRating)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RatingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rating.FieldOrigin:
		return m.Origin()
	case rating.FieldOriginalRating:
		return m.OriginalRating()
	case rating.FieldNormalizedRating:
		return m.NormalizedRating()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RatingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rating.FieldOrigin:
		return m.OldOrigin(ctx)
	case rating.FieldOriginalRating:
		return m.OldOriginalRating(ctx)
	case rating.FieldNormalizedRating:
		return m.OldNormalizedRating(ctx)
	}
	return nil, fmt.Errorf("unknown Rating field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RatingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rating.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case rating.FieldOriginalRating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalRating(v)
		return nil
	case rating.FieldNormalizedRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalizedRating(v)
		return nil
	}
	return fmt.Errorf("unknown Rating field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RatingMutation) AddedFields() []string {
	var fields []string
	if m.addnormalized_rating != nil {
		fields = append(fields, rating.FieldNormalizedRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RatingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rating.FieldNormalizedRating:
		return m.AddedNormalizedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RatingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rating.FieldNormalizedRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalizedRating(v)
		return nil
	}
	return fmt.Errorf("unknown Rating numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RatingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RatingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RatingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rating nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RatingMutation) ResetField(name string) error {
	switch name {
	case rating.FieldOrigin:
		m.ResetOrigin()
		return nil
	case rating.FieldOriginalRating:
		m.ResetOriginalRating()
		return nil
	case rating.FieldNormalizedRating:
		m.ResetNormalizedRating()
		return nil
	}
	return fmt.Errorf("unknown Rating field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RatingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RatingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RatingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RatingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RatingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RatingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RatingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Rating unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RatingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Rating edge %s", name)
}
